#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    Claw_Pot,       sensorPotentiometer)
#pragma config(Sensor, in6,    AutoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  Lift_Switch,    sensorTouch)
#pragma config(Sensor, dgtl6,  Lift_Enc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           rightInside,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftOutside,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightDriveFront, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftDriveFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightOutside,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftInside,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
task liftcontrol();
volatile int Lift_Position;
int Lift_PositionCount = 1;
volatile int Lift_ControlActive = false;
volatile int Lift_Power;
#define Lift_UpperLimit 2000 //(190)
#define Lift_Pos1 0 //(2720)
#define Lift_Pos2 1000
#define Lift_Pos3 1849
#define Lift_PosRelease 1400
#define Lift_EncoderZero 0
#define Lift_HardStop 1850
volatile bool Break;
task clawcontrol(); // Close + Open -
volatile int ClawActive = true;
volatile int Claw_Position;
volatile int Claw_Power;
#define Claw_Open 3600 //(150)
#define Claw_Closed 1300//(2310)
#define Claw_ClosedCube 1930
#define Claw_Mid 2300
#define Mid 0
#define Closed 1
#define Open 2
volatile int ClawPos = -1;

#define LCD_LEFT 1
#define LCD_CENTER 2
#define LCD_RIGHT 4
#define TPR_SPEED 360
int auto = 0;
bool picked = false;

void liftZero(){
	SensorValue[Lift_Enc] = Lift_EncoderZero;
}

task ProgramChooser() {
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	const int max = 9;
	const int min = 0;

	string autoName = "";

	while (!picked) {
		if (nLCDButtons == LCD_LEFT) {
			while (nLCDButtons != 0) {
			}
			auto--;
			} else if (nLCDButtons == LCD_RIGHT) {
			while (nLCDButtons != 0) {
			}
			auto++;
			} else if (nLCDButtons == LCD_CENTER) {
			while(nLCDButtons != 0) {
			}
			picked = true;
		}
		if (auto < min) {
			auto = max;
			} else if (auto > max) {
			auto = min;
		}
		switch (auto) {
		case 0: autoName = "[Right Cube]"; break;
		case 1: autoName = "[Right Stars]"; break;
		case 2: autoName = "[Left Cube]"; break;
		case 3: autoName = "[Left Cone]" ; break;
		case 4: autoName = "[Prog Skills]"; break;
		default: autoName = "None"; break;
		}
		displayLCDCenteredString(0,autoName);
		displayLCDCenteredString(1,"<            >");
	}
}

const unsigned int TrueSpeed[128] =
{
	25,  25,  25,  25,  25,  25,  25,  25,  25,  25,
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
	25, 25, 26, 26, 26, 27, 28, 28, 28, 29,
	29, 30, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90, 127, 127, 127
};

void SetDrive(int LeftDrivePower, int RightDrivePower){
	LeftDrivePower = LeftDrivePower > 127 ? 127 : LeftDrivePower;
	LeftDrivePower = LeftDrivePower < -127 ? -127 : LeftDrivePower;
	RightDrivePower = RightDrivePower > 127 ? 127 : RightDrivePower;
	RightDrivePower = RightDrivePower < -127 ? -127 : RightDrivePower;
	if(vexRT(Btn7L) == true){
		if(RightDrivePower > 0)
			RightDrivePower = TrueSpeed[RightDrivePower];
		else if(RightDrivePower < 0)
			RightDrivePower = -TrueSpeed[-RightDrivePower];
		else
			RightDrivePower = 0;
		LeftDrivePower = RightDrivePower;
	}
	else{
		if(LeftDrivePower > 0)
			LeftDrivePower = TrueSpeed[LeftDrivePower];
		else if(LeftDrivePower < 0)
			LeftDrivePower = -TrueSpeed[-LeftDrivePower];
		else
			LeftDrivePower = 0;
		// right
		if(RightDrivePower > 0)
			RightDrivePower = TrueSpeed[RightDrivePower];
		else if(RightDrivePower < 0)
			RightDrivePower = -TrueSpeed[-RightDrivePower];
		else
			RightDrivePower = 0;
	}
	motor[rightDriveFront] = RightDrivePower;
	motor[rightDriveBack] = RightDrivePower;
	motor[leftDriveFront] = LeftDrivePower;
	motor[leftDriveBack] = LeftDrivePower;
}



void RotateAngle(int DesiredAngle,int MaxTime,int PowerLimit) {

	//send a neg. angle to turn right.right rotations go negative, power to rotate right is L+,R-
	int NotDone;int LeftPwr;int RightPwr;int PreviousError;int RotationError;int RotationPwr;
	const float RotationkD=2.0; const float RotationkP=0.29; 	const int SuccessThreshold=15; // this is 1.5 degrees //0.29 for 100 speed, 0.25 for 127 speed
	float Dvalue=0.0;int BrakePwr;
	const float DvalueLimit=30.0;
	int BrakeVal=40;// 16 was good, went to 40 so upped pwer to 24 then 40
	int BrakeTime=60;//in msecs 120 was great but need speed

	PreviousError=0; DesiredAngle*=10;
	if (DesiredAngle > 0) BrakePwr= -BrakeVal;
	else BrakePwr= BrakeVal;
	SensorValue[gyro]= 0;
	// set to Neg of desired angle, then seek zero
	// when TheError is pos, brake fails
	clearTimer(T1);NotDone=1;
	while(((time100[T1]) < MaxTime) && NotDone) {
		RotationError=DesiredAngle - (SensorValue[gyro]);// TheError is error value
		if (abs(RotationError) < SuccessThreshold) {
			NotDone=0;
			LeftPwr= -BrakePwr; RightPwr= BrakePwr;
			motor[rightDriveFront] = RightPwr;

			motor[rightDriveBack] = RightPwr;

			motor[leftDriveFront] = LeftPwr;

			motor[leftDriveBack] = LeftPwr;
			wait1Msec(BrakeTime);
			//testcode
			SetDrive(0,0);
		}
		else {
			Dvalue=(RotationError-PreviousError)*RotationkD;	PreviousError=RotationError;
			//Limit Dval
			if (Dvalue > DvalueLimit) Dvalue=DvalueLimit;
			else if (Dvalue < -DvalueLimit) Dvalue=-DvalueLimit;
			RotationPwr=(int)((RotationError*RotationkP)+Dvalue);
			// Limiter-code
			if (RotationPwr < -PowerLimit) RotationPwr=-PowerLimit;
			else if (RotationPwr > PowerLimit) RotationPwr= PowerLimit;
			LeftPwr= -RotationPwr; RightPwr= RotationPwr;
			motor[rightDriveFront] = RightPwr;

			motor[rightDriveBack] = RightPwr;

			motor[leftDriveFront] = LeftPwr;

			motor[leftDriveBack] = LeftPwr;
		}
		wait1Msec(10);// find best val for this. was 2
	}
	SetDrive(0,0);
}



task DriveControl();
volatile bool BreakLoop;
volatile int DriveMode;
volatile float DesiredDriveValue;
volatile bool FirstLockCheck = false;
volatile bool UnderLoad;
volatile bool DriveActive;
volatile float LinekP = .25;
#define Line 1
#define Rotation 2
#define Off 3
#define F 1
#define B -1
#define R -1
#define L 1
int LeftTurnConst;
int RightTurnConst;
float NoLoadLeftTurnConst = 7.8;
float NoLoadRightTurnConst = 7.8;
float TurnConst;
void SetDriveControl(int Mode, int Value, int Time){
	DriveMode = Mode;
	SensorValue(rightEncoder) = 0;
	SensorValue(gyro) = 0;
	TurnConst = (sgn(Value) == -1) ? NoLoadRightTurnConst : NoLoadLeftTurnConst;
	DesiredDriveValue = (Mode == Line) ? (Value*360)/10.205 : (Value * TurnConst);
	clearTimer(T1);

	BreakLoop = false;
	DriveActive = true;
	while(BreakLoop == false && time1[T1] < (Time*1000)){
		wait1Msec(20);
	}
	FirstLockCheck = false;
	BreakLoop = false;
	DriveActive = false;
}
void SetLiftMotors(int Power){
	motor[rightInside] = Power;
	motor[rightOutside] = Power;
	motor[leftInside] = Power;
	motor[leftOutside] = Power;
}
void SetLiftPosition(int Position){
	Lift_Position = Position;
}
void Dump(int LiftPos){
	DriveActive = false;
	SetDrive(-120, -120);
	Lift_ControlActive = false;
	Lift_Power = 127;
	clearTimer(T2);
	while(Break == false && time1[T2] < 1000){
		if(SensorValue(Lift_Enc) < Lift_PosRelease){
			ClawPos = Open;
			Claw_Position = Open;
			wait1Msec(500);
			Break = true;
		}
		wait1Msec(20);
	}
	Break = false;
	Lift_ControlActive = true;
	SetLiftPosition(LiftPos);
	wait1Msec(500);
	SetDrive(0, 0);
	wait1Msec(250);
	DriveActive = true;
}


void Auto(){

}
string sLStandard = "Standard Left";
string sLElims_Front = "Elims Front Left";
string sLElims_Back = "Elims Back Left";
string sProgrammingSkills = "Skills";
string sNone = "None";
string sRElims_Back = "Elims Back Right";
string sRElims_Front = "Elims Front Right";
string sRStandard = "Standard Right";
string SelectedAuton;
void DisplayAuto(){
	if(SensorValue(AutoPot) < 500){
		SelectedAuton = sLStandard;
	}
	else if(SensorValue(AutoPot) < 1000){
		SelectedAuton = sLElims_Front;
	}
	else if(SensorValue(AutoPot) < 1500){
		SelectedAuton = sLElims_Back;
	}
	else if(SensorValue(AutoPot) < 2000){
		SelectedAuton = sProgrammingSkills;
	}
	else if(SensorValue(AutoPot) < 2500){
		SelectedAuton = sNone;
	}
	else if(SensorValue(AutoPot) < 3000){
		SelectedAuton = sRElims_Back;
	}
	else if(SensorValue(AutoPot) < 3500){
		SelectedAuton = sRElims_Front;
	}
	else{
		SelectedAuton = sRStandard;
	}
	bLCDBacklight = true;
	clearLCDLine(0); clearLCDLine(1);
	displayLCDString(0, 0, SelectedAuton);
}

void RightCube(){
	ClawPos = Open;
	Claw_Position = Claw_Open+300;
	sleep(1000);
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);
	SetDriveControl(Line, 20, 1);
	/*
	SetDrive(127,127);
	sleep(400);27);
	sleep(100);
	SetDrive(-127,-1
	SetDrive(0,0);
	sleep(10);
	*/
	ClawPos = Open;
	Claw_Position = Claw_Open+300;
	wait1Msec(750);
	//wait1Msec(300);
	wait1Msec(1000);
	RotateAngle(90,1000,100);
	wait1Msec(500);

	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(300);

	SetLiftPosition(Lift_Pos1);

	wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(300);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(300);
	//RotateAngle(90,1000,100);
	SetDriveControl(Line, -30, 2);
	wait1Msec(700);
	RotateAngle(88,1000,100);
	//RotateAngle(-10,1000,100);
	SetDriveControl(Line, -20, 2);
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(1050);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	sleep(200);
	SetLiftPosition(Lift_Pos1);
}


void rightStrs(){
	sleep(4000);
	SetDriveControl(Line, -3, 1);
	sleep(250);
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;
	ClawPos = Open;
	Claw_Position = Claw_Mid;
	wait1Msec(800);
	//wait1Msec(500);
	SetDriveControl(Line, 24.5, 1);
	wait1Msec(1200);

	ClawPos = Open;
	Claw_Position = Claw_Closed;
	wait1Msec(500);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(600);
	SetDriveControl(Line, -25, 1);
	wait1Msec(1500);
	RotateAngle(75,1000,100);

	wait1Msec(600);
	SetDriveControl(Line, -26, 1);
	wait1Msec(2000);

	SetLiftPosition(Lift_Pos3+150);
	wait1Msec(1000);
	ClawPos = Open;
	Claw_Position = Claw_Open;
}

void LeftCone(){

	Lift_ControlActive = true;
	SetLiftPosition(Lift_Pos1);
	SetDriveControl(Line, -3 , 1);
	sleep(1000);
	Claw_Position = Claw_Open;
		ClawPos = Open;
	sleep(1000);

	SetDriveControl(Line, 10 , 1);
	sleep(1700);
	Claw_Position = Claw_Closed;
	SetLiftPosition(Lift_Pos2);
	RotateAngle(-85 , 1000 , 80);
	SetDriveControl(Line , -20 , 1);
	sleep(1700);
	SetLiftPosition(Lift_Pos3);

	/*
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 13, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(750);

	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	wait1Msec(1000);

	ClawPos = Open;
	Claw_Position = Claw_Closed;
	wait1Msec(500);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(600);
	SetDriveControl(Line, -27, 1);
	wait1Msec(1500);
	RotateAngle(-75,1000,100);

	wait1Msec(600);
	SetDriveControl(Line, -26, 1);
	wait1Msec(1500);

	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(1000);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	*/

}

void LeftCube(){

	/*SetDriveControl(Line, -3, 1);
	sleep(250);
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;
	ClawPos = Open;
	Claw_Position = Claw_Mid;
	wait1Msec(800);
	//wait1Msec(500);
	SetDriveControl(Line, 12, 1);
	wait1Msec(1200);
	*/
	SetDriveControl(Line, 20, 1);
	sleep(2000);
	ClawPos = Open;
	Claw_Position = Claw_Open;

	/*
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;
	ClawPos = Open;
	Claw_Position = Claw_Open;
	//wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	SetLiftPosition(Lift_Pos2-100);
	RotateAngle(-90,1000,100);
	wait1Msec(500);

	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(300);



	SetLiftPosition(Lift_Pos1);


	wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(300);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(300);
	//RotateAngle(90,1000,100);
	SetDriveControl(Line, -28, 2);
	wait1Msec(700);
	RotateAngle(-88,1000,100);
	//RotateAngle(-10,1000,100);
	SetDriveControl(Line, -14, 2);
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(750);
	ClawPos = Open;
	Claw_Position = Claw_Open;

	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 16, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open-100;
	wait1Msec(750);

	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	wait1Msec(1000);
	*/
}

void DumpAuto(int time){
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(time);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	sleep(1000);
	SetLiftPosition(Lift_Pos1);

	sleep(2000);
}

void PreloadDump(int time, float distance){

	SetDriveControl(Line, distance, 1);
	sleep(2500);
	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	sleep(1000);
	SetDriveControl(Line, (-1)*distance, 1);
	sleep(2000);
	DumpAuto(time);
}
void ProgSkill(){
	/*
	rightStrs();
	sleep(1000);
	SetLiftPosition(Lift_Pos1);
	ClawPos = Open;
	Claw_Position = Claw_Mid;
	sleep(1000);
	PreloadDump(1200,26);
	sleep(2000);
	PreloadDump(1200,24);
	sleep(2000);
	PreloadDump(1000,24);
	sleep(2000);
	*/
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 10, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(750);

}

void pre_auton(){
	SensorType(in3) = sensorNone;
	wait1Msec(1000);
	SensorType(in3) = sensorGyro;
	wait1Msec(1000);
	liftZero();
	sleep(500);
	bStopTasksBetweenModes = true;
	SensorValue(rightEncoder) = 0;
	//DisplayAuto();
	startTask(ProgramChooser);
}


task autonomous(){
	startTask(liftcontrol); startTask(clawcontrol); startTask(DriveControl);

	stopTask(ProgramChooser);
	switch(auto) {
	case 0: RightCube(); break;
	case 1: rightStrs(); break;
	case 2: LeftCube(); break;
	case 3: LeftCone(); break;
	case 4: ProgSkill(); break;

	}
}

task usercontrol(){
	startTask(liftcontrol); startTask(clawcontrol);
	bool Lift_Toggle1 = false; bool Lift_Toggle2 = false;
	bool Claw_Toggle = false; ClawPos = -1;
	int buttonToggleState = 1; int buttonPressed = 0;
	int LeftDrive; int RightDrive;
	sleep(50);

	while (true){

		if(vexRT[Btn7D]){
			SensorValue[Lift_Enc] = 0;
		}

		if(vexRT[Btn7L] == 1){
			if(!buttonPressed ){
				buttonToggleState = 1 - buttonToggleState;
				buttonPressed = 1;


			}
			}else{
			buttonPressed = 0;
		}

		if(vexRT(Btn8R) == true){
			LeftDrive = 60;
			RightDrive = -60;
		}
		else{
			LeftDrive = abs(vexRT(Ch3)) > 25 ? vexRT(Ch3) : 0;
			RightDrive = abs(vexRT(Ch2)) > 25 ? vexRT(Ch2) : 0;
		}
		SetDrive(LeftDrive, RightDrive);
		if(vexRT(Btn5U) == 1){
			if(SensorValue(Lift_Enc) > Lift_PosRelease){
				ClawPos = Open;
			}
			if(SensorValue[Lift_Enc] > Lift_HardStop && buttonToggleState == 1){
				Lift_ControlActive = true;
				Lift_PositionCount = 3;
				Lift_Power = 0;
				}else{
				Lift_ControlActive = false;
				Lift_PositionCount = 1;
				Lift_Power = -127;
			}
		}
		else if (vexRT(Btn5D) == 1){
			Lift_ControlActive = false;
			Lift_PositionCount = 1;
			//Lift_Power = 127;
			SetLiftMotors(80);
		}
		else{
			Lift_Power = 0;
		}
		if(vexRT(Btn8U) == 1){
			ClawPos = Mid;
		}
		if(ClawPos == 3){
			ClawPos = Mid;
		}

		if(vexRT(Btn6U) == 1){
			if(Claw_Toggle == false){
				ClawPos++;
				if(ClawPos > 3){
					ClawPos = 1;
				}
				Claw_Toggle = true;
			}
		}
		else{
			Claw_Toggle = false;
		}
		if(vexRT(Btn7D) == 1){
			if(Lift_Toggle1 == false){
				Lift_PositionCount = Lift_PositionCount - 1;
				if(Lift_PositionCount > 1){
					Lift_PositionCount = 1;
				}
				Lift_ControlActive = true;
			}
			Lift_Toggle1 = true;
		}
		else{
			Lift_Toggle1 = false;
		}
		if(vexRT(Btn6D) == 1){
			if(Lift_Toggle2 == false){
				Lift_PositionCount++;
				if(Lift_PositionCount > 3){
					Lift_PositionCount = 3;
				}
				Lift_ControlActive = true;
			}
			Lift_Toggle2 = true;
		}
		else{
			Lift_Toggle2 = false;
		}
		if(ClawPos == Closed){
			Claw_Position = Claw_Closed;
		}
		else if (ClawPos == Mid){
			Claw_Position = Claw_Mid;
		}
		else if (ClawPos == Open){
			Claw_Position = Claw_Open;
		}
		switch(Lift_PositionCount){
		case 1:
			SetLiftPosition(Lift_Pos1);
			break;
		case 2:
			SetLiftPosition(Lift_Pos2);
			break;
		case 3:
			SetLiftPosition(Lift_Pos3);
			break;
		}
	}
}
task clawcontrol(){
	int Claw_Current; float Claw_kP = 0.2;
	//Claw_Current = 0;
	while(true){
		if(ClawActive){
			//Update Values
			Claw_Current = SensorValue(Claw_Pot); //Current Error
			if(ClawPos == Closed){
				Claw_Power = ((Claw_Position - Claw_Current) * Claw_kP);
				//Claw_Power = Claw_Power < 0 ? 0 : Claw_Power;
			}
			else if(ClawPos == Open){
				Claw_Power = ((Claw_Position - Claw_Current) * Claw_kP * 1.05);
				//Claw_Power = Claw_Power > 0 ? 0 : Claw_Power;
			}
			else if(ClawPos == Mid){
				Claw_Power = ((Claw_Position - Claw_Current) * Claw_kP * 1.05);
			}
			//System Limits
			if(SensorValue(Claw_Pot) > Claw_Closed){
				//	Claw_Power = Claw_Power > 0 ? 0 : Claw_Power;
			}
			if(SensorValue(Claw_Pot) < Claw_Open){
				//	Claw_Power = Claw_Power < 0 ? 0 : Claw_Power;
			}
			writeDebugStreamLine("int x is: %d", Claw_Power);
			motor[clawLeft] = Claw_Power;
			motor[clawRight] = Claw_Power;
			wait1Msec(20);
		}
	}
}
task liftcontrol(){
	int Lift_Current; float DkP; int Lift_Hold = 10;
	while (true){
		if(Lift_ControlActive){
			Lift_Current = SensorValue(Lift_Enc);
			DkP = ((Lift_Position - Lift_Current) > 0) ? .12 : .07;
			Lift_Power = (-(Lift_Position - Lift_Current) * DkP + Lift_Hold);
			if(Lift_Position == Lift_Pos1){
				if(Lift_Power > 30){
					Lift_Power = 30;
				}
			}
		}
		if(SensorValue(Lift_Switch) == true && SensorValue(Lift_Enc) > 1500){
			if(Lift_Power < 0){
				Lift_Power = 0;
			}
			else{
				Lift_Power = Lift_Power;
			}
		}
		if(SensorValue(Lift_Enc) < Lift_UpperLimit){
			if(Lift_Power > 0){
				Lift_Power = 0;
			}
			else{
				Lift_Power = Lift_Power;
			}
		}
		SetLiftMotors(Lift_Power);
		wait1Msec(20);
	}
}
task DriveControl(){
	int DrivePower; int DriveDirection; float CurrentDriveValue; float DkP; float DkI;
	int LockingThreshold = 15;
	int BrakingPower; int BrakingTime; short BatteryLvl;
	int P; int I; int IVal = 0; int I_Limit = 20;
	while(true){
		if(DriveActive){
			CurrentDriveValue = DriveMode == Line ? SensorValue(rightEncoder) : SensorValue(gyro);
			DriveDirection = sgn(DrivePower);
			DkP = DriveMode == Line ? LinekP : .2;
			if(DriveMode == Rotation){
				DkP = DesiredDriveValue > (75 * TurnConst) ? .2 : .25;
			}
			DkI = DriveMode == Line ? 0 : .0;
			BrakingPower = DriveMode == Line ? 20 : 80;
			//if(DriveMode == Line){
			BrakingTime = 80;
			/*}
			else if(DriveMode == Rotation){
			BrakingTime = abs(DesiredDriveValue) > 720 ? 150 : 100;
			}*/
			P = (DesiredDriveValue - CurrentDriveValue);
			IVal = IVal + P;
			I = IVal * DkI;
			I = I < I_Limit ? I : I_Limit;
			I = I > -I_Limit ? I : -I_Limit;
			if(abs(P) > LockingThreshold){
				DrivePower = P * DkP + I;
			}
			if(abs(P) < LockingThreshold){
				DrivePower = -DriveDirection*BrakingPower;
				IVal = 0;
				FirstLockCheck = true;
			}
			BatteryLvl = nImmediateBatteryLevel/1000;
			DrivePower = (DrivePower * pow(8.4/BatteryLvl, 2));
			switch(DriveMode){
			case Line: SetDrive(DrivePower, DrivePower);    break;
			case Rotation: SetDrive(-DrivePower, DrivePower); break;
			case Off: SetDrive(0,0); break;
			}
			if(FirstLockCheck == true){
				wait1Msec(BrakingTime);
				SetDrive(0,0);
				wait1Msec(50);
				if(abs(P) < LockingThreshold){
					BreakLoop = true;
				}
				else{
					FirstLockCheck = false;
				}
			}
			wait1Msec(5);
		}
		else{
			wait1Msec(5);
		}
	}
}
