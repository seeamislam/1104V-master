#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    ClawRight_Pot,  sensorPotentiometer)
#pragma config(Sensor, in6,    ClawLeft_Pot,   sensorPotentiometer)
#pragma config(Sensor, in7,    AutoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl4,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  Lift_Enc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  Lift_Switch,    sensorTouch)
#pragma config(Sensor, dgtl9,  BumpSwtichBack, sensorDigitalIn)
#pragma config(Sensor, dgtl10, BumpSwitch,     sensorDigitalIn)
#pragma config(Sensor, dgtl11, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightInside,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftOutside,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightDriveFront, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDriveBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftDriveFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightOutside,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftInside,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
task liftcontrol();
volatile int Lift_Position;
int Lift_PositionCount = 1;
volatile int Lift_ControlActive = false;
volatile int Lift_Power;
#define Lift_UpperLimit 2000 //(190)
#define Lift_Pos1 0 //(2720)
#define Lift_Pos2 1000
#define Lift_Pos3 1800
#define Lift_PosRelease 1400
#define Lift_EncoderZero 0
#define Lift_HardStop 1900
volatile bool Break;
volatile int ClawActive = true;
volatile int Claw_Position;
volatile int Claw_Power;
#define Claw_Open 3600 //(150)
#define Claw_Closed 1300//(2310)
#define Claw_ClosedCube 1930
#define Claw_Mid 2300
#define Mid 0
#define Closed 1
#define Open 2
volatile int ClawPos = -1;

task clawLeftcontrol(); // Close + Open -
volatile int ClawLeftActive = true;
volatile int ClawLeft_Position;
volatile int ClawLeft_Power;
task clawRightcontrol();
volatile int ClawRightActive = true;
volatile int ClawRight_Position;
volatile int ClawRight_Power;

#define ClawLeft_Open 1549 //(150)
#define ClawLeft_Closed 550 //(2310)
#define ClawLeft_ClosedCube 656
#define ClawLeft_Mid 957

#define ClawRight_Open 2212 //(150)
#define ClawRight_Closed 3350 //(2310)
#define ClawRight_ClosedCube 3222
#define ClawRight_Mid 2888

#define LCD_LEFT 1
#define LCD_CENTER 2
#define LCD_RIGHT 4
#define TPR_SPEED 360
int auto = 0;
bool picked = false;

void liftZero(){
	SensorValue[Lift_Enc] = Lift_EncoderZero;
}


task ProgramChooser() {
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	const int max = 9;
	const int min = 0;

	string autoName = "";

	while (!picked) {
		if (nLCDButtons == LCD_LEFT) {
			while (nLCDButtons != 0) {
			}
			auto--;
			} else if (nLCDButtons == LCD_RIGHT) {
			while (nLCDButtons != 0) {
			}
			auto++;
			} else if (nLCDButtons == LCD_CENTER) {
			while(nLCDButtons != 0) {
			}
			picked = true;
		}
		if (auto < min) {
			auto = max;
			} else if (auto > max) {
			auto = min;
		}
		switch (auto) {
		case 0: autoName = "[Right Cube]"; break;
		case 1: autoName = "[Right Stars]"; break;
		case 2: autoName = "[Left Cube]"; break;
		case 3: autoName = "[Left Cone]" ; break;
		case 4: autoName = "[Prog Skills]"; break;
		default: autoName = "None"; break;
		}
		displayLCDCenteredString(0,autoName);
		displayLCDCenteredString(1,"<            >");
	}
}
const unsigned int TrueSpeed[128] =
{
	25,  25,  25,  25,  25,  25,  25,  25,  25,  25,
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
	25, 25, 26, 26, 26, 27, 28, 28, 28, 29,
	29, 30, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90, 127, 127, 127
};
void SetDrive(int LeftDrivePower, int RightDrivePower){
	LeftDrivePower = LeftDrivePower > 127 ? 127 : LeftDrivePower;
	LeftDrivePower = LeftDrivePower < -127 ? -127 : LeftDrivePower;
	RightDrivePower = RightDrivePower > 127 ? 127 : RightDrivePower;
	RightDrivePower = RightDrivePower < -127 ? -127 : RightDrivePower;
	if(vexRT(Btn7L) == true){
		if(RightDrivePower > 0)
			RightDrivePower = TrueSpeed[RightDrivePower];
		else if(RightDrivePower < 0)
			RightDrivePower = -TrueSpeed[-RightDrivePower];
		else
			RightDrivePower = 0;
		LeftDrivePower = RightDrivePower;
	}
	else{
		if(LeftDrivePower > 0)
			LeftDrivePower = TrueSpeed[LeftDrivePower];
		else if(LeftDrivePower < 0)
			LeftDrivePower = -TrueSpeed[-LeftDrivePower];
		else
			LeftDrivePower = 0;
		// right
		if(RightDrivePower > 0)
			RightDrivePower = TrueSpeed[RightDrivePower];
		else if(RightDrivePower < 0)
			RightDrivePower = -TrueSpeed[-RightDrivePower];
		else
			RightDrivePower = 0;
	}
	motor[rightDriveFront] = RightDrivePower;
	motor[rightDriveBack] = RightDrivePower;
	motor[leftDriveFront] = LeftDrivePower;
	motor[leftDriveBack] = LeftDrivePower;
}



void RotateAngle(int DesiredAngle,int MaxTime,int PowerLimit) {

	//send a neg. angle to turn right.right rotations go negative, power to rotate right is L+,R-
	int NotDone;int LeftPwr;int RightPwr;int PreviousError;int RotationError;int RotationPwr;
	const float RotationkD=2.0; const float RotationkP=0.29; 	const int SuccessThreshold=15; // this is 1.5 degrees //0.29 for 100 speed, 0.25 for 127 speed
	float Dvalue=0.0;int BrakePwr;
	const float DvalueLimit=30.0;
	int BrakeVal=40;// 16 was good, went to 40 so upped pwer to 24 then 40
	int BrakeTime=60;//in msecs 120 was great but need speed

	PreviousError=0; DesiredAngle*=10;
	if (DesiredAngle > 0) BrakePwr= -BrakeVal;
	else BrakePwr= BrakeVal;
	SensorValue[gyro]= 0;
	// set to Neg of desired angle, then seek zero
	// when TheError is pos, brake fails
	clearTimer(T1);NotDone=1;
	while(((time100[T1]) < MaxTime) && NotDone) {
		RotationError=DesiredAngle - (SensorValue[gyro]);// TheError is error value
		if (abs(RotationError) < SuccessThreshold) {
			NotDone=0;
			LeftPwr= -BrakePwr; RightPwr= BrakePwr;
			motor[rightDriveFront] = RightPwr;

			motor[rightDriveBack] = RightPwr;

			motor[leftDriveFront] = LeftPwr;

			motor[leftDriveBack] = LeftPwr;
			wait1Msec(BrakeTime);
			//testcode
			SetDrive(0,0);
		}
		else {
			Dvalue=(RotationError-PreviousError)*RotationkD;	PreviousError=RotationError;
			//Limit Dval
			if (Dvalue > DvalueLimit) Dvalue=DvalueLimit;
			else if (Dvalue < -DvalueLimit) Dvalue=-DvalueLimit;
			RotationPwr=(int)((RotationError*RotationkP)+Dvalue);
			// Limiter-code
			if (RotationPwr < -PowerLimit) RotationPwr=-PowerLimit;
			else if (RotationPwr > PowerLimit) RotationPwr= PowerLimit;
			LeftPwr= -RotationPwr; RightPwr= RotationPwr;
			motor[rightDriveFront] = RightPwr;

			motor[rightDriveBack] = RightPwr;

			motor[leftDriveFront] = LeftPwr;

			motor[leftDriveBack] = LeftPwr;
		}
		wait1Msec(10);// find best val for this. was 2
	}
	SetDrive(0,0);
}



task DriveControl();
volatile bool BreakLoop;
volatile int DriveMode;
volatile float DesiredDriveValue;
volatile bool FirstLockCheck = false;
volatile bool UnderLoad;
volatile bool DriveActive;
volatile float LinekP = .25;
#define Line 1
#define Rotation 2
#define Off 3
#define F 1
#define B -1
#define R -1
#define L 1
int LeftTurnConst;
int RightTurnConst;
float NoLoadLeftTurnConst = 7.8;
float NoLoadRightTurnConst = 7.8;
float TurnConst;
void SetDriveControl(int Mode, int Value, int Time){
	DriveMode = Mode;
	SensorValue(leftEncoder) = 0;
	SensorValue(gyro) = 0;
	TurnConst = (sgn(Value) == -1) ? NoLoadRightTurnConst : NoLoadLeftTurnConst;
	DesiredDriveValue = (Mode == Line) ? (Value*360)/10.205 : (Value * TurnConst);
	clearTimer(T1);

	BreakLoop = false;
	DriveActive = true;
	while(BreakLoop == false && time1[T1] < (Time*1000)){
		wait1Msec(20);
	}
	FirstLockCheck = false;
	BreakLoop = false;
	DriveActive = false;
}
void SetLiftMotors(int Power){
	motor[rightInside] = Power;
	motor[rightOutside] = Power;
	motor[leftInside] = Power;
	motor[leftOutside] = Power;
}

void SetLiftPosition(int Position){
	Lift_Position = Position;
}

void liftPositionOne(){
	while(SensorValue(BumpSwitch) == 1){
			Lift_ControlActive = false;
			Lift_PositionCount = 1;
			//Lift_Power = 127;
			SetLiftMotors(80);
			Lift_ControlActive = true;
			SetLiftPosition(Lift_Pos1);
	}
}

void setClawPosition(int rightClawPosition, int leftClawPosition){
	ClawRight_Position = rightClawPosition;
	ClawLeft_Position = leftClawPosition;
}

void Dump(int LiftPos){
	DriveActive = false;
	SetDrive(-120, -120);
	Lift_ControlActive = false;
	Lift_Power = 127;
	clearTimer(T2);
	while(Break == false && time1[T2] < 1000){
		if(SensorValue(Lift_Enc) < Lift_PosRelease){
			ClawPos = Open;
			Claw_Position = Open;
			wait1Msec(500);
			Break = true;
		}
		wait1Msec(20);
	}
	Break = false;
	Lift_ControlActive = true;
	SetLiftPosition(LiftPos);
	wait1Msec(500);
	SetDrive(0, 0);
	wait1Msec(250);
	DriveActive = true;
}


void Auto(){

}
string sLStandard = "Standard Left";
string sLElims_Front = "Elims Front Left";
string sLElims_Back = "Elims Back Left";
string sProgrammingSkills = "Skills";
string sNone = "None";
string sRElims_Back = "Elims Back Right";
string sRElims_Front = "Elims Front Right";
string sRStandard = "Standard Right";
string SelectedAuton;
void DisplayAuto(){
	if(SensorValue(AutoPot) < 500){
		SelectedAuton = sLStandard;
	}
	else if(SensorValue(AutoPot) < 1000){
		SelectedAuton = sLElims_Front;
	}
	else if(SensorValue(AutoPot) < 1500){
		SelectedAuton = sLElims_Back;
	}
	else if(SensorValue(AutoPot) < 2000){
		SelectedAuton = sProgrammingSkills;
	}
	else if(SensorValue(AutoPot) < 2500){
		SelectedAuton = sNone;
	}
	else if(SensorValue(AutoPot) < 3000){
		SelectedAuton = sRElims_Back;
	}
	else if(SensorValue(AutoPot) < 3500){
		SelectedAuton = sRElims_Front;
	}
	else{
		SelectedAuton = sRStandard;
	}
	bLCDBacklight = true;
	clearLCDLine(0); clearLCDLine(1);
	displayLCDString(0, 0, SelectedAuton);
}

void RightCube(){

	Lift_ControlActive = true;

	SetDriveControl(Line, 19.5, 1);
	wait1Msec(250);
	RotateAngle(90,1000,100);
	wait1Msec(100);
	ClawPos = Open;
	Claw_Position = Claw_Open-100;
	wait1Msec(75);
	SetLiftPosition(Lift_Pos1);
	//ClawPos = Closed;
	//Claw_Position = Claw_Closed;
	//wait1Msec(300);
	delay(125);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(150);

	SetLiftPosition(Lift_Pos1);

	wait1Msec(200);
	SetDriveControl(Line, 17, 1);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(300);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(300);
	//RotateAngle(90,1000,100);
	SetDriveControl(Line, -28, 2);
	wait1Msec(300);
	RotateAngle(80,1000,100);
	//RotateAngle(-10,1000,100);
	SetDriveControl(Line, -18.5, 1.5);
	wait1Msec(150);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(1050);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	sleep(200);
	SetLiftPosition(Lift_Pos1);
}


void rightStrs(){
	SetDriveControl(Line, -3, 1);
	sleep(250);
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;
	ClawPos = Open;
	Claw_Position = Claw_Mid;
	wait1Msec(800);
	//wait1Msec(500);
	SetDriveControl(Line, 24.5, 1);
	wait1Msec(1200);

	ClawPos = Open;
	Claw_Position = Claw_Closed;
	wait1Msec(500);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(600);
	SetDriveControl(Line, -25, 1);
	wait1Msec(1500);
	RotateAngle(75,1000,100);

	wait1Msec(600);
	SetDriveControl(Line, -26, 1);
	wait1Msec(2000);

	SetLiftPosition(Lift_Pos3+150);
	wait1Msec(1000);
	ClawPos = Open;
	Claw_Position = Claw_Open;
}

void LeftCone(){
	sleep(6666);
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 16, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open-100;
	wait1Msec(750);

	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	wait1Msec(1000);
	RotateAngle(-95,1000,100);
	wait1Msec(500);

	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(300);

	SetLiftPosition(Lift_Pos1);

	wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(300);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(300);
	//RotateAngle(90,1000,100);
	SetDriveControl(Line, -28, 2);
	wait1Msec(700);
	RotateAngle(-88,1000,100);
	//RotateAngle(-10,1000,100);
	SetDriveControl(Line, -17, 2);
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(1050);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	sleep(200);
	SetLiftPosition(Lift_Pos1);



	/*
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 13, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(750);

	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	wait1Msec(1000);

	ClawPos = Open;
	Claw_Position = Claw_Closed;
	wait1Msec(500);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(600);
	SetDriveControl(Line, -27, 1);
	wait1Msec(1500);
	RotateAngle(-75,1000,100);

	wait1Msec(600);
	SetDriveControl(Line, -26, 1);
	wait1Msec(1500);

	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(1000);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	*/

}

void LeftCube(){

	Lift_ControlActive = true;

	ClawPos = Open;
	setClawPosition(ClawRight_Open, ClawLeft_Open);
	liftPositionOne();
	wait1Msec(150);
	SetDriveControl(Line, 18, 1);
	wait1Msec(150);
	RotateAngle(-84,1000,100);
	wait1Msec(150);


	//ClawPos = Closed;
	//Claw_Position = Claw_Closed;
	//wait1Msec(300);

	SetDriveControl(Line, 17, 1);
	wait1Msec(150);
	ClawPos = Closed;
	setClawPosition(ClawRight_Closed, ClawLeft_Closed);
	wait1Msec(450);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(150);
	SetDriveControl(Line, -25, 2);
	wait1Msec(150);
	RotateAngle(-80,1000,100);
	wait1Msec(150);
	SetDriveControl(Line, -26, 1.5);
	wait1Msec(200);
	SetLiftPosition(Lift_Pos3 + 200);
	wait1Msec(800);
	ClawPos = Open;
	setClawPosition(ClawRight_Open, ClawLeft_Open);
	wait1Msec(250);
	liftPositionOne();
	wait1Msec(50);
	//SetLiftPosition(Lift_Pos2);
	//wait1Msec(150);
	//SetDriveControl(Line, 10, 1);
	//wait1Msec(150);
	//RotateAngle(45,1000,100);
	//wait1Msec(150);
	//SetDriveControl(Line, -4, 1);
	//wait1Msec(100);
	//liftPositionOne();
	//SetDriveControl(Line, 30, 1);
	//wait1Msec(150);
	//ClawPos = Closed;
	//setClawPosition(ClawRight_Closed, ClawLeft_Closed);
	//wait1Msec(450);
	//SetLiftPosition(Lift_Pos2);
	//wait1Msec(400);
	//RotateAngle(84,1000,100);
	//wait1Msec(200);
	//SetDriveControl(Line, 5, 1);
	//wait1Msec(150);
	//ClawPos = Open;
	//setClawPosition(ClawRight_Open, ClawLeft_Open);
	//SetDriveControl(Line, -30, 1);
	//wait1Msec(150);
	//RotateAngle(-84,1000,100);
	//wait1Msec(150);
	//SetDriveControl(Line, -33, 1);
	//wait1Msec(150);
	//SetLiftPosition(Lift_Pos3 + 200);
	//wait1Msec(800);
	//ClawPos = Open;
	//setClawPosition(ClawRight_Open, ClawLeft_Open);
	//wait1Msec(250);
	/*
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;
	ClawPos = Open;
	Claw_Position = Claw_Open;
	//wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	SetLiftPosition(Lift_Pos2-100);
	RotateAngle(-90,1000,100);
	wait1Msec(500);

	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(300);



	SetLiftPosition(Lift_Pos1);


	wait1Msec(500);
	SetDriveControl(Line, 15, 1);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(300);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(300);
	//RotateAngle(90,1000,100);
	SetDriveControl(Line, -28, 2);
	wait1Msec(700);
	RotateAngle(-88,1000,100);
	//RotateAngle(-10,1000,100);
	SetDriveControl(Line, -14, 2);
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(750);
	ClawPos = Open;
	Claw_Position = Claw_Open;

	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 16, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open-100;
	wait1Msec(750);

	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	//wait1Msec(300);
	wait1Msec(1000);
	*/
}

void ProgrammingSkills(){
	Lift_ControlActive = true;
	SetLiftPosition(Lift_Pos1);
	wait1Msec(50);
	//FIRST CUBE PRELOAD + STAR PRELOAD
	SetDriveControl(Line, -20, 1);
	wait1Msec(50);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(500);
	SetDriveControl(Line, 12, 1);
	wait1Msec(500);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube - 100;
	wait1Msec(450);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(200);
	while(SensorValue(BumpSwitch) == 0){
	SetDriveControl(Line, -40, 2);
	}
	wait1Msec(500);
	SetLiftPosition(Lift_Pos3 + 100);
	wait1Msec(800);
	ClawPos = Open;
	Claw_Position = Claw_Open - 100;
	wait1Msec(200);
	liftPositionOne();
	wait1Msec(200);
	//SECOND CUBE PRELOAD + STAR PRELOAD
	SetDriveControl(Line, 27, 1);
	wait1Msec(500);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube - 100;
	wait1Msec(150);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(200);
	SetDriveControl(Line, -34, 2);
	wait1Msec(450);
	SetLiftPosition(Lift_Pos3 + 100);
	wait1Msec(650);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(200);
	liftPositionOne();
	wait1Msec(200);
	//TURN TO PICK UP THREE STARS
	SetLiftPosition(Lift_Pos2);
	wait1Msec(400);
	RotateAngle(-87,1000,100);
	wait1Msec(400);
	SetDriveControl(Line, -7, 1);
	wait1Msec(400);
	liftPositionOne();
	wait1Msec(425);
	SetDriveControl(Line, 8, 1);
	wait1Msec(425);
	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	wait1Msec(425);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(425);
	SetDriveControl(Line, -4, 1);
	RotateAngle(80,1000,100);
	wait1Msec(425);
	SetDriveControl(Line, -10, 1);
	wait1Msec(400);
	liftPositionOne();
	wait1Msec(400);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(400);
	SetDriveControl(Line, 27, 1);
	wait1Msec(400);
	ClawPos = Closed;
	Claw_Position = Claw_Closed + 200;
	wait1Msec(400);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(200);
	SetDriveControl(Line, -34, 2);
	wait1Msec(450);
	SetLiftPosition(Lift_Pos3 + 100);
	wait1Msec(650);
	//90/100 score in DECA BMOR Provincials
	//2 Callbacks in Nature's Fury FLL Ontario Provincials (No Award)
	//1 Day Internship at PaperBagLabs Inc.
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(400);
	liftPositionOne();
	wait1Msec(200);
	//FIRST CUBE
	SetDriveControl(Line, -10, 1.5);
	wait1Msec(400);
	SetDriveControl(Line, 20, 1);
	wait1Msec(400);
	RotateAngle(85,1000,100);
	wait1Msec(400);
	SetDriveControl(Line, 25, 1);
	wait1Msec(400);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(400);
	SetLiftPosition(Lift_Pos2);
	wait1Msec(400);
	SetDriveControl(Line, -27, 1);
	wait1Msec(500);
	RotateAngle(-79,1000,100);
	SetDriveControl(Line, -20, 1);
	wait1Msec(450);
	SetLiftPosition(Lift_Pos3 + 100);
	wait1Msec(650);
	ClawPos = Open;
	Claw_Position = Claw_Open - 100;
	wait1Msec(500);
	liftPositionOne();
	wait1Msec(400);
	//FENCE BOTTOM MIDDLE STARS
	SetDriveControl(Line, 10, 1);
	wait1Msec(400);
	RotateAngle(83,1000,100);
	wait1Msec(400);
	ClawPos = Closed;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(400);
	SetDriveControl(Line, -15, 1);
	wait1Msec(400);
	SetDriveControl(Line, 25, 1);
	wait1Msec(400);
	ClawPos = Open;
	Claw_Position = Claw_Open - 100;
	wait1Msec(400);
	SetDriveControl(Line, 30, 1);
	wait1Msec(400);
	ClawPos = Open;
	Claw_Position = Claw_ClosedCube;
	wait1Msec(400);



}

/*void GayNiggerPrabh(){
//First load
Lift_PositionCount = 1;
SetDriveControl(Line, 20*B, 3);
ClawPos = Open;
wait1Msec(1500);
ClawPos = Closed;
wait1Msec(1000);
Lift_PositionCount = 4;
RampUp(B);
SetDriveControl(Line, 35*B, 1);
wait1Msec(500);
Dump();
wait1Msec(300);

//Second load
SetDriveControl(Line, 2*B, 0.1);
wait1Msec(200);
ClawPos = Mid;
SetDriveControl(Line, 27, 1);
wait1Msec(600);
ClawPos = Closed;
wait1Msec(500);
Lift_PositionCount = 4;
RampUp(B);
SetDriveControl(Line, 34*B, 1);
wait1Msec(500);
Dump();
wait1Msec(300);

//Third load
Lift_PositionCount = 2;
ClawPos = Mid;
wait1Msec(400);
SetDriveControl(Line, 1.5*B, 0.1);
wait1Msec(200);
SetDriveControl(Line, 4, 0.25);
wait1Msec(200);
SetDriveControl(Rotation, 90*-Side, 1);
wait1Msec(500);
Lift_PositionCount = 1;
wait1Msec(300);
SetDriveControl(Line, 7, 0.25);
wait1Msec(200);
ClawPos = Closed;
wait1Msec(200);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Line, 1*B, 0.5);
wait1Msec(200);
SetDriveControl(Rotation, 90*Side, 1);
wait1Msec(500);
Lift_PositionCount = 4;
wait1Msec(300);
ClawPos = Open;
SetDriveControl(Line, 25, 1.75);
wait1Msec(300);
ClawPos = Closed;
wait1Msec(1000);
Lift_PositionCount = 4;
wait1Msec(500);
SetDriveControl(Line, 36*B, 1);
wait1Msec(500);
Dump();
wait1Msec(300);
SetDriveControl(Line, 1.5*B, 0.1);
wait1Msec(300);

//Middle cube
ClawPos = Mid;
SetDriveControl(Line, 20, 1.75);
wait1Msec(300);
SetDriveControl(Rotation, 90*Side, 1);
wait1Msec(500);
SetDriveControl(Line, 28, 2);
wait1Msec(300);
ClawPos = Closed;
wait1Msec(1200);
Lift_PositionCount = 4;
wait1Msec(500);
SetDriveControl(Line, 30*B, 1);
wait1Msec(500);
SetDriveControl(Rotation, 80*-Side, 1);
wait1Msec(500);
SetDriveControl(Line, 20*B, 1);
wait1Msec(500);
Dump();
wait1Msec(300);

//Front 3 stars
ClawPos = Mid;
Lift_PositionCount = 2;
wait1Msec(500);
SetDriveControl(Rotation, 90*Side, 1);
wait1Msec(500);
Lift_PositionCount = 1;
wait1Msec(500);
SetDriveControl(Line, 35, 1.75);
wait1Msec(300);
ClawPos = Closed;
wait1Msec(600);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Rotation, 80*-Side, 1);
wait1Msec(500);
SetDriveControl(Line, 5*B, 1);
wait1Msec(500);
Dump();
wait1Msec(500);

//Back 3 stars
SetDriveControl(Line, 32, 1.75);
wait1Msec(300);
ClawPos = Closed;
wait1Msec(1000);
SetDriveControl(Line, 5*B, 1);
wait1Msec(500);
ClawPos = Open;
SetDriveControl(Line, 5, 1);
wait1Msec(500);
ClawPos = Closed;
wait1Msec(900);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Line, 35*B, 1.75);
wait1Msec(600);
Dump();
wait1Msec(200);

//Last Cube
SetDriveControl(Rotation, 30*Side, 1);
wait1Msec(500);
SetDriveControl(Line, 30, 1.75);
wait1Msec(600);
ClawPos = Closed;
wait1Msec(600);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Rotation, 20*-Side, 1);
wait1Msec(1000);
SetDriveControl(Line, 35*B, 1.75);
wait1Msec(600);
Dump();
wait1Msec(300);


//Corner Star
SetDriveControl(Rotation, 90*Side, 1);
wait1Msec(500);
Lift_PositionCount = 4;
wait1Msec(300);
ClawPos = Mid;
Lift_PositionCount = 1;
wait1Msec(300);
SetDriveControl(Line, 38, 2);
wait1Msec(600);
ClawPos = Closed;
wait1Msec(300);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Rotation, 90*-Side, 1);
wait1Msec(500);
Lift_PositionCount = 1;
wait1Msec(300);
ClawPos = Mid;
SetDriveControl(Line, 38, 2);
wait1Msec(600);
ClawPos = Closed;
wait1Msec(500);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Line, 38*B, 2);
wait1Msec(600);
Dump();
wait1Msec(600);


//Hang
SetDriveControl(Line, 25, 1.75);
wait1Msec(600);
SetDriveControl(Rotation, 180*-Side, 1);
wait1Msec(500);
Lift_PositionCount = 4;
wait1Msec(300);
SetDriveControl(Line, 25*B, 1.75);
wait1Msec(1000);
SetDriveControl(Line, 8, 1);
wait1Msec(600);
SetDriveControl(Rotation, 45*Side, 1);
wait1Msec(500);
SetDriveControl(Line, 8*B, 1);
wait1Msec(600);
Lift_PositionCount = 3;
wait1Msec(300);
Hang();
wait1Msec(10000);



}
*/


void DumpAuto(int time){
	wait1Msec(400);
	SetLiftPosition(Lift_Pos3+200);
	wait1Msec(time);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	sleep(1000);
	SetLiftPosition(Lift_Pos1);

	sleep(2000);
}

void PreloadDump(int time, float distance){

	SetDriveControl(Line, distance, 1);
	sleep(2500);
	ClawPos = Closed;
	Claw_Position = Claw_Closed;
	sleep(1000);
	SetDriveControl(Line, (-1)*distance, 1);
	sleep(2000);
	DumpAuto(time);
}
void ProgSkill(){
	/*
	rightStrs();
	sleep(1000);
	SetLiftPosition(Lift_Pos1);
	ClawPos = Open;
	Claw_Position = Claw_Mid;
	sleep(1000);
	PreloadDump(1200,26);
	sleep(2000);
	PreloadDump(1200,24);
	sleep(2000);
	PreloadDump(1000,24);
	sleep(2000);
	*/
	SetLiftPosition(Lift_Pos1);
	Lift_ControlActive = true;

	SetLiftPosition(Lift_Pos2-100);

	SetDriveControl(Line, 10, 1);
	ClawPos = Open;
	Claw_Position = Claw_Open;
	wait1Msec(750);

}



void testValues(){
ClawPos = Open;
setClawPosition(ClawRight_Open, ClawLeft_Open);
wait1Msec(1500);
ClawPos = Mid;
setClawPosition(ClawRight_Mid, ClawLeft_Mid);
wait1Msec(1500);
ClawPos = Closed;
setClawPosition(ClawRight_Closed, ClawLeft_Closed);
wait1Msec(500);

}

void pre_auton(){
	SensorType(in3) = sensorNone;
	wait1Msec(1000);
	SensorType(in3) = sensorGyro;
	wait1Msec(1000);
	liftZero();
	sleep(500);
	bStopTasksBetweenModes = true;
	SensorValue(leftEncoder) = 0;
	//DisplayAuto();
	startTask(ProgramChooser);
}


task autonomous(){
	startTask(liftcontrol); startTask(clawLeftcontrol); startTask(clawRightcontrol); startTask(DriveControl);

	stopTask(ProgramChooser);
	switch(auto) {
		//Change this shit nigga (case 0: RightCube();)
	case 0: testValues(); break;
	case 1: rightStrs(); break;
	case 2: LeftCube(); break;
	case 3: LeftCone(); break;
	case 4: ProgrammingSkills(); break;

	}
}



task usercontrol(){
	startTask(liftcontrol); startTask(clawLeftcontrol); startTask(clawRightcontrol);
	bool Lift_Toggle1 = false; bool Lift_Toggle2 = false;
	bool Claw_Toggle = false; ClawPos = -1;
	int buttonToggleState = 1; int buttonPressed = 0;
	int LeftDrive; int RightDrive;
	SensorValue[Lift_Enc] = 0;
	sleep(50);

	while (true){

		if(vexRT[Btn7L] == 1){
			if(!buttonPressed ){
				buttonToggleState = 1 - buttonToggleState;
				buttonPressed = 1;
			}
			}else{
			buttonPressed = 0;
		}

		if(vexRT(Btn8R) == true){
			LeftDrive = 60;
			RightDrive = -60;
		}
		else{
			LeftDrive = abs(vexRT(Ch3)) > 25 ? vexRT(Ch3) : 0;
			RightDrive = abs(vexRT(Ch2)) > 25 ? vexRT(Ch2) : 0;
		}
		SetDrive(LeftDrive, RightDrive);
		if(vexRT(Btn5U) == 1){
			if(SensorValue(Lift_Enc) > Lift_PosRelease){
				ClawPos = Open;
			}
			if(SensorValue[Lift_Enc] > Lift_HardStop && buttonToggleState == 1){
				Lift_ControlActive = true;
				Lift_PositionCount = 3;
				Lift_Power = 0;
				}else{
				Lift_ControlActive = false;
				Lift_PositionCount = 1;
				Lift_Power = -127;
			}
		}
		else if (vexRT(Btn5D) == 1){
			Lift_ControlActive = false;
			Lift_PositionCount = 1;
			//Lift_Power = 127;
			SetLiftMotors(80);
		}
		else{
			Lift_Power = 0;
		}
		if(vexRT(Btn8U) == 1){
			ClawPos = Mid;
		}
		if(ClawPos == 3){
			ClawPos = Mid;
		}

		if(vexRT(Btn6U) == 1){
			if(Claw_Toggle == false){
				ClawPos++;
				if(ClawPos > 3){
					ClawPos = 1;
				}
				Claw_Toggle = true;
			}
		}
		else{
			Claw_Toggle = false;
		}
		if(vexRT(Btn7D) == 1){
			if(Lift_Toggle1 == false){
				Lift_PositionCount = Lift_PositionCount - 1;
				if(Lift_PositionCount > 1){
					Lift_PositionCount = 1;
				}
				Lift_ControlActive = true;
			}
			Lift_Toggle1 = true;
		}
		else{
			Lift_Toggle1 = false;
		}
		if(vexRT(Btn6D) == 1){
			if(Lift_Toggle2 == false){
				Lift_PositionCount++;
				if(Lift_PositionCount > 3){
					Lift_PositionCount = 3;
				}
				Lift_ControlActive = true;
			}
			Lift_Toggle2 = true;
		}
		else{
			Lift_Toggle2 = false;
		}
		if(ClawPos == Closed){
			ClawLeft_Position = ClawLeft_Closed;
			ClawRight_Position = ClawRight_Closed;
		}
		else if (ClawPos == Mid){
			ClawLeft_Position = ClawLeft_Mid;
			ClawRight_Position = ClawRight_Mid;
		}
		else if (ClawPos == Open){
			ClawLeft_Position = ClawLeft_Open;
			ClawRight_Position = ClawRight_Open;
		}
		switch(Lift_PositionCount){
		case 1:
			SetLiftPosition(Lift_Pos1);
			break;
		case 2:
			SetLiftPosition(Lift_Pos2);
			break;
		case 3:
			SetLiftPosition(Lift_Pos3);
			break;
		}
	}
}

task clawLeftcontrol(){
	int Claw_Current; float Claw_kP = .25;
	while(true){
		if(ClawLeftActive){
			//Update Values
			Claw_Current = SensorValue(ClawLeft_Pot); //Current Error

			if(ClawPos == Closed){
				ClawLeft_Power = ((ClawLeft_Position - Claw_Current) * Claw_kP);
				//ClawLeft_Power = ClawLeft_Power < 0 ? 0 : ClawLeft_Power;
			}
			else if(ClawPos == Open){
				ClawLeft_Power = ((ClawLeft_Position - Claw_Current) * Claw_kP * 0.9);
				//ClawLeft_Power = ClawLeft_Power > 0 ? 0 : ClawLeft_Power;
			}
			else if(ClawPos == Mid){
				ClawLeft_Power = ((ClawLeft_Position - Claw_Current) * Claw_kP * 0.35);
			}

			//System Limits
			//if(SensorValue(ClawLeft_Pot) > ClawLeft_Closed){
			//	ClawLeft_Power = ClawLeft_Power > 0 ? 0 : ClawLeft_Power;
			//}

			//if(SensorValue(ClawLeft_Pot) < ClawLeft_Open){
			//	ClawLeft_Power = ClawLeft_Power < 0 ? 0 : ClawLeft_Power;
			//}
			motor[ClawLeft] = ClawLeft_Power;

			wait1Msec(20);
		}
	}
}


task clawRightcontrol(){
	int ClawRight_Current; float Claw_kP = .25;
	while(true){
		if(ClawLeftActive){
			//Update Values
			ClawRight_Current = SensorValue(ClawRight_Pot); //Current Error

			if(ClawPos == Closed){
				ClawRight_Power = ((ClawRight_Position - ClawRight_Current) * Claw_kP);
			//	ClawRight_Power = ClawRight_Power < 0 ? 0 : ClawRight_Power;
			}
			else if(ClawPos == Open){
				ClawRight_Power = ((ClawRight_Position - ClawRight_Current) * Claw_kP * 0.9);
			//	ClawRight_Power = ClawRight_Power > 0 ? 0 : ClawRight_Power;
			}
			else if(ClawPos == Mid){
				ClawRight_Power = ((ClawRight_Position - ClawRight_Current) * Claw_kP * 0.35);
			}

			//System Limits
			//if(SensorValue(ClawLeft_Pot) > ClawLeft_Closed){
			//	ClawLeft_Power = ClawLeft_Power > 0 ? 0 : ClawLeft_Power;
			//}

			//if(SensorValue(ClawLeft_Pot) < ClawLeft_Open){
			//	ClawLeft_Power = ClawLeft_Power < 0 ? 0 : ClawLeft_Power;
			//}
			motor[ClawRight] = ClawRight_Power;

			wait1Msec(20);
		}
	}
}

task liftcontrol(){
	int Lift_Current; float DkP; int Lift_Hold = 15;
	while (true){
		if(Lift_ControlActive){
			Lift_Current = SensorValue(Lift_Enc);
			DkP = ((Lift_Position - Lift_Current) > 0) ? .24 : .14;
			Lift_Power = (-(Lift_Position - Lift_Current) * DkP + Lift_Hold);
			if(Lift_Position == Lift_Pos1){
			Lift_Power = 80;
			}
		}
		if(SensorValue(Lift_Switch) == true && SensorValue(Lift_Enc) > 1500){
			if(Lift_Power < 0){
				Lift_Power = 0;
			}
			else{
				Lift_Power = Lift_Power;
			}
		}
		if(SensorValue(Lift_Enc) < Lift_UpperLimit){
			if(Lift_Power > 0){
				Lift_Power = 0;
			}
			else{
				Lift_Power = Lift_Power;
			}
		}
		SetLiftMotors(Lift_Power);
		wait1Msec(20);
	}
}
task DriveControl(){
	int DrivePower; int DriveDirection; float CurrentDriveValue; float DkP; float DkI;
	int LockingThreshold = 15;
	int BrakingPower; int BrakingTime; short BatteryLvl;
	int P; int I; int IVal = 0; int I_Limit = 20;
	while(true){
		if(DriveActive){
			CurrentDriveValue = DriveMode == Line ? SensorValue(leftEncoder) : SensorValue(gyro);
			DriveDirection = sgn(DrivePower);
			DkP = DriveMode == Line ? LinekP : .2;
			if(DriveMode == Rotation){
				DkP = DesiredDriveValue > (75 * TurnConst) ? .2 : .25;
			}
			DkI = DriveMode == Line ? 0 : .0;
			BrakingPower = DriveMode == Line ? 20 : 80;
			//if(DriveMode == Line){
			BrakingTime = 80;
			/*}
			else if(DriveMode == Rotation){
			BrakingTime = abs(DesiredDriveValue) > 720 ? 150 : 100;
			}*/
			P = (DesiredDriveValue - CurrentDriveValue);
			IVal = IVal + P;
			I = IVal * DkI;
			I = I < I_Limit ? I : I_Limit;
			I = I > -I_Limit ? I : -I_Limit;
			if(abs(P) > LockingThreshold){
				DrivePower = P * DkP + I;
			}
			if(abs(P) < LockingThreshold){
				DrivePower = -DriveDirection*BrakingPower;
				IVal = 0;
				FirstLockCheck = true;
			}
			BatteryLvl = nImmediateBatteryLevel/1000;
			DrivePower = (DrivePower * pow(8.4/BatteryLvl, 2));
			switch(DriveMode){
			case Line: SetDrive(DrivePower, DrivePower);    break;
			case Rotation: SetDrive(-DrivePower, DrivePower); break;
			case Off: SetDrive(0,0); break;
			}
			if(FirstLockCheck == true){
				wait1Msec(BrakingTime);
				SetDrive(0,0);
				wait1Msec(50);
				if(abs(P) < LockingThreshold){
					BreakLoop = true;
				}
				else{
					FirstLockCheck = false;
				}
			}
			wait1Msec(5);
		}
		else{
			wait1Msec(5);
		}
	}
}
