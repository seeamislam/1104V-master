#pragma config(Sensor, in1,    Auto,           sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro1,          sensorGyro)
#pragma config(Sensor, in6,    LeftClawPot,    sensorPotentiometer)
#pragma config(Sensor, in8,    RightClawPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  Drive_Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  Climb_Switch,   sensorTouch)
#pragma config(Sensor, dgtl6,  Lift_Encoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, Lift_Switch,    sensorTouch)
#pragma config(Motor,  port1,           RightClaw,     tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           Lift_C,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Lift_B,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           RightDriveA,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           LeftDriveA,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RightDriveB,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           LeftDriveB,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Lift_A,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Lift_D,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          LeftClaw,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

task liftcontrol();
volatile int Lift_Position = 0;
int Lift_PositionCount = 1;
volatile int Lift_Power;
#define Lift_UpperLimit 2100
#define Lift_Pos1 -15
#define Lift_Pos2 682
#define Lift_Pos3 2000
#define Lift_PosAuto 400
#define Lift_PosRelease 1700

task Lclawcontrol();
task Rclawcontrol();
volatile int LeftClaw_Position = 0;
volatile int LeftClaw_Power;

#define RightClaw_Open 3190 //(150)
#define RightClaw_Closed 2115 //(2310)
#define RightClaw_Mid 2595

volatile int RightClaw_Position = 0;
volatile int RightClaw_Power;

#define LeftClaw_Open 537 //(150)
#define LeftClaw_Closed 1700
#define LeftClaw_Mid 1165

#define Mid 2
#define Closed 1
#define Open 3
#define ClawThreshold 25

volatile int ClawPos = 0;

#include "SpicyFunctions.c"
#include "SpicyAutos.c"

#define LCD_LEFT 1
#define LCD_CENTER 2
#define LCD_RIGHT 4
#define TPR_SPEED 360
int auto = 0;
bool picked = false;

task ProgramChooser() {
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	const int max = 9;
	const int min = 0;

	string autoName = "";

	while (!picked) {
		if (nLCDButtons == LCD_LEFT) {
			while (nLCDButtons != 0) {
			}
			auto--;
			} else if (nLCDButtons == LCD_RIGHT) {
			while (nLCDButtons != 0) {
			}
			auto++;
			} else if (nLCDButtons == LCD_CENTER) {
			while(nLCDButtons != 0) {
			}
			picked = true;
		}
		if (auto < min) {
			auto = max;
			} else if (auto > max) {
			auto = min;
		}
		switch (auto) {
		case 0: autoName = "[Top]"; break;
		default: autoName = "None"; break;
		}
		displayLCDCenteredString(0,autoName);
		displayLCDCenteredString(1,"<            >");
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton(){

	bStopTasksBetweenModes = true;
	SensorValue(Drive_Encoder) = 0;
	SensorValue(Lift_Encoder) = 0;

	SensorType[in3] = sensorNone;
	wait1Msec(3000);
	SensorType[in3] = sensorGyro;
	wait1Msec(1000);


	while (bIfiRobotDisabled) {
		//DisplayAuto();
	}

		startTask(ProgramChooser);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// lol gay
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous(){
	startTask(liftcontrol); startTask(Lclawcontrol); startTask(Rclawcontrol);startTask(DriveControl);
	//DisplayAuto();

	stopTask(ProgramChooser);
	switch(auto) {
		//Change this shit nigga (case 0: RightCube();)
	case 0: Skills(1); break;


	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){
	startTask(liftcontrol); startTask(Lclawcontrol); startTask(Rclawcontrol);
	 bool Lift_Toggle2 = false;
	bool Claw_Toggle = false;
	int LeftDriveA; int RightDriveA; int LeftDriveB; int RightDriveB;
	while (true){
		//DisplayAuto();
		LeftDriveA = abs(vexRT(Ch3)) > 20 ? vexRT(Ch3) : 0;
		RightDriveA = abs(vexRT(Ch2)) > 20 ? vexRT(Ch2) : 0;
		LeftDriveB = abs(vexRT(Ch3)) > 20 ? vexRT(Ch3) : 0;
		RightDriveB = abs(vexRT(Ch2)) > 20 ? vexRT(Ch2) : 0;
		SetDrive(LeftDriveA, RightDriveA, LeftDriveB, RightDriveB);

		if(vexRT(Btn5U) == 1){
			Lift_PositionCount = -1;
		}
		else{
			if(Lift_PositionCount == -1){
			Lift_PositionCount = 0;
		}
	}

		if(vexRT(Btn6U) == 1){
			if(Claw_Toggle == false){
				ClawPos--;
				ClawPos = (ClawPos < 1) ? 3 : ClawPos;
				Claw_Toggle = true;
			}
		}
		else{
			Claw_Toggle = false;
		}

		if(vexRT(Btn5D) == 1){
			Lift_PositionCount = -4;
	}
			else{
			if(Lift_PositionCount == -4){
				Lift_PositionCount = 0;
		}
		}

		if(vexRT(Btn8U) == 1){
            Lift_PositionCount = -5;
        }
        else{
            if(Lift_PositionCount == -5)
            {
                Lift_PositionCount = -3;
            }
        }

		if(vexRT(Btn6D) == 1){
			if(Lift_Toggle2 == false){
				Lift_PositionCount++;

				if(Lift_PositionCount > 3){
					Lift_PositionCount = 3;
				}

			}
			Lift_Toggle2 = true;
		}
		else{
			Lift_Toggle2 = false;
		}

		if(vexRT(Btn8D) == 1){
			startTask(DriveControl);
			//Auto();
			stopTask(DriveControl);
		}
	}
}

task paarthRushiClaw(){
	if(ClawPos == Open){
		while(SensorValue(RightClawPot) < RightClaw_Open){
			motor[RightClaw] = -127;
		}
	}else if(ClawPos == Closed){
			while(SensorValue(RightClawPot) > RightClaw_Closed){
			motor[RightClaw] = 127;
		}
	}

}

task Lclawcontrol(){
	int LeftClaw_Current;
	int LeftClawP;
	float LeftClaw_kP = .2;
	while(true){

			switch(ClawPos){
			case 1:
			LeftClaw_Position = LeftClaw_Closed;
			break;
			case 2:
			LeftClaw_Position = LeftClaw_Mid;
			break;
			case 3:
			LeftClaw_Position = LeftClaw_Open;
			break;
			}

			LeftClaw_Current = SensorValue(LeftClawPot); //Current Error
			LeftClawP = LeftClaw_Position - LeftClaw_Current;
			LeftClaw_Power = LeftClawP * LeftClaw_kP;

			//System Limits
			//if(SensorValue(LeftClawPot) > LeftClaw_Closed){
			//	LeftClaw_Power = LeftClaw_Power > 0 ? 0 : LeftClaw_Power;
			//}

			//if(SensorValue(LeftClawPot) < LeftClaw_Open){
			//	LeftClaw_Power = LeftClaw_Power < 0 ? 0 : LeftClaw_Power;
			//}
			motor[LeftClaw] = LeftClaw_Power;
			wait1Msec(20);
		}
}

task Rclawcontrol(){
	int RightClaw_Current;
	int RightClawP;
	float RightClaw_kP = .2;
	while(true){
			switch(ClawPos){
			case 1:
			RightClaw_Position = RightClaw_Closed;
			break;
			case 2:
			RightClaw_Position = RightClaw_Mid;
			break;
			case 3:
			RightClaw_Position = RightClaw_Open;
			break;
			}

			RightClaw_Current = (SensorValue(RightClawPot)); //Current Error
			RightClawP = RightClaw_Position - RightClaw_Current;
			RightClaw_Power = RightClawP * RightClaw_kP;
			////System Limits
			//if(SensorValue(RightClawPot) > RightClaw_Closed){
			//	RightClaw_Power = RightClaw_Power;
			//}

			//if(SensorValue(RightClawPot) < RightClaw_Open){
			//	RightClaw_Power = RightClaw_Power;
			//}
			motor[RightClaw] = RightClaw_Power;
			wait1Msec(20);
	}
}
task liftcontrol(){
	int Lift_Current; float LkP = 0.3; int Lift_Hold = 0; int LP;
	while (true){
		Lift_Current = abs(SensorValue(Lift_Encoder));
		LP = Lift_Position - Lift_Current;
		switch(Lift_PositionCount){
	  case -5:
    if(SensorValue(Climb_Switch) == 0)
    {
    Lift_Power = 127;
    }
    else{
    Lift_Power = 0;
    }

    break;
		case -4:
		if(SensorValue(Lift_Switch) == 1){
		    Lift_Power = -15;
				SensorValue(Lift_Encoder) = 0;
			}
		    Lift_Power = -127;
		break;
		case -3:
		Lift_Power = 0;
		break;
		case -2:
		Lift_Power = 127;
		break;
		case -1:
			SetLiftPosition(Lift_UpperLimit);
			Lift_Power = (LP*2.5 - 30);
			if(Lift_Current > Lift_PosRelease){
			ClawPos = Open;
			}
			break;
		case 0:
			Lift_Power = (Lift_Current < Lift_UpperLimit) ? 0 : (LP * LkP - 20);
				if(SensorValue(Lift_Switch) == 1){
				Lift_Power = -30;
				SensorValue(Lift_Encoder) = 0;
			}
			break;
		case 1:
			SetLiftPosition(Lift_Pos1);
			if(SensorValue(Lift_Switch) == 1){
				Lift_Power = -30;
				SensorValue(Lift_Encoder) = 0;
			}
			else{
				Lift_Power = (LP * LkP + Lift_Hold);
			}
			break;

		case 2:
			SetLiftPosition(Lift_Pos2);
			Lift_Power = (LP * LkP + Lift_Hold);
			break;

		case 3:
			SetLiftPosition(Lift_Pos3);
			Lift_Power = (LP * LkP + Lift_Hold);
			break;
		case 4:
		SetLiftPosition(Lift_PosAuto);
			Lift_Power = (LP * LkP + Lift_Hold);
		break;
	}
		SetLiftMotors(Lift_Power);
		wait1Msec(20);
	}
}

task DriveControl(){

	int DrivePower; int DriveDirection; float CurrentDriveValue; float DkP;
	int LockingThreshold = 15;
	int BrakingPower; int BrakingTime; short BatteryLvl;
	int P;
	while(true){
		if(DriveActive){
			CurrentDriveValue = DriveMode == Line ? -SensorValue(Drive_Encoder) : SensorValue(Gyro1);
			DriveDirection = sgn(DrivePower);
			DkP = DriveMode == Line ? LinekP : .2;
			if(DriveMode == Rotation){
				DkP = DesiredDriveValue > (75 * TurnConst) ? .13 : .13;
			}
			BrakingPower = DriveMode == Line ? 20 : 80;

			BrakingTime = 120;
			P = (DesiredDriveValue - CurrentDriveValue);
			if(abs(P) > LockingThreshold){
				DrivePower = P * DkP;
			}
			if(abs(P) < LockingThreshold){
				DrivePower = -DriveDirection*BrakingPower;
				FirstLockCheck = true;
			}
			BatteryLvl = nImmediateBatteryLevel/1000;
			DrivePower = (DrivePower * pow(8.4/BatteryLvl, 2));
			switch(DriveMode){
			case Line: SetDrive(DrivePower, DrivePower);	break;
			case Rotation: SetDrive(-DrivePower, DrivePower); break;
			case Off: SetDrive(0,0); break;
			}
			if(FirstLockCheck == true){
				wait1Msec(BrakingTime);
				SetDrive(0,0);
				wait1Msec(0);
				if(abs(P) < LockingThreshold){
					BreakLoop = true;
				}
				else{
					FirstLockCheck = false;
				}
			}
			wait1Msec(5);
		}
		else{
			wait1Msec(5);
		}
	}
}
