#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftTopOut,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           rightTopOut,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBotIn,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightBotOut,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftBotIn,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftBotOut,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftTopIn,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightTopIn,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)


#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

int CMToTicks(float cm){
const int WHEEL_CIRCUMFERENCE = 10.21;
int numOfRevolutions;
int ticks;
cm = WHEEL_CIRCUMFERENCE * numOfRevolutions;
numOfRevolutions = cm/WHEEL_CIRCUMFERENCE;
ticks = numOfRevolutions*90;
return ticks;
}
void tank(int left, int right) {
	motor[leftDrive] = left;
	motor[rightDrive] = right;
}
void RotateAngle(int DesiredAngle,int MaxTime,int PowerLimit) {
	//send a neg. angle to turn right.right rotations go negative, power to rotate right is L+,R-
	int NotDone;int LeftPwr;int RightPwr;int PreviousError;int RotationError;int RotationPwr;
	const float RotationkD=2.0; const float RotationkP=0.3;	const int SuccessThreshold=15; // this is 1.5 degrees
	float Dvalue=0.0;int BrakePwr;
	const float DvalueLimit=30.0;
	int BrakeVal=40;// 16 was good, went to 40 so upped pwer to 24 then 40
	int BrakeTime=60;//in msecs 120 was great but need speed

	PreviousError=0; DesiredAngle*=10;
	if (DesiredAngle > 0) BrakePwr= -BrakeVal;
	else BrakePwr= BrakeVal;
	SensorValue[gyro]= 0;
	// set to Neg of desired angle, then seek zero
	// when TheError is pos, brake fails
	clearTimer(T1);NotDone=1;
	while(((time100[T1]) < MaxTime) && NotDone) {
		RotationError=DesiredAngle - (-SensorValue[gyro]);// TheError is error value
		if (abs(RotationError) < SuccessThreshold) {
			NotDone=0;
			LeftPwr= -BrakePwr; RightPwr= BrakePwr;
			motor[driveRight]=RightPwr;motor[driveLeft]=LeftPwr;
					wait1Msec(BrakeTime);
			//testcode
			tank(0,0);
		}
		else {
			Dvalue=(RotationError-PreviousError)*RotationkD;	PreviousError=RotationError;
			//Limit Dval
			if (Dvalue > DvalueLimit) Dvalue=DvalueLimit;
			else if (Dvalue < -DvalueLimit) Dvalue=-DvalueLimit;
			RotationPwr=(int)((RotationError*RotationkP)+Dvalue);
			// Limiter-code
			if (RotationPwr < -PowerLimit) RotationPwr=-PowerLimit;
			else if (RotationPwr > PowerLimit) RotationPwr= PowerLimit;
			LeftPwr= -RotationPwr; RightPwr= RotationPwr;
				motor[driveRight]=RightPwr;motor[driveLeft]=LeftPwr;
		}
		wait1Msec(10);// find best val for this. was 2
	}
	tank(0,0);
}
int trueSpeed(int power) {
	int tsArray[128] =
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		5,10,12,13,13,14,15,15,15,15,
		20,20,20,20,20,20,20,20,20,20,
		25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
		35, 35, 35, 35, 35, 35, 35, 35, 35, 35,
		41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
		46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
		52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
		61, 62, 63, 64, 65, 66, 67, 68, 72, 77,
		82, 87, 92, 97, 103, 108, 113, 118, 120, 125,
		126,127,127,127,127,127,127,127,127,127,
		127,127,127,127,127,127,127,127
	};
	return ((power>0)?1:-1)*tsArray[power*((power>0)?1:-1)];
}
void drivePID(int distance){

const float Kp = 0.2;
const float Ki = 0.05;
const float Kd = 0.5;

//this can also be changed
float INTEGRAL_POWER_LIMIT = 50/Ki;
float INTEGRAL_ACTIVE = CMToTicks(7.5); 


int proportional;
int derivative;
int preIntegral;
int integral;
int error;
int lastError;

SensorValue[rightEncoder]=0;

while(1==1){
error = CMToTicks(distance) - SensorValue[rightEncoder]; 
proportional = error*Kp;

if(abs(error) < INTEGRAL_ACTIVE && error != 0){
preIntegral = preIntegral+error;
}else {
preIntegral = 0;
}
if(preIntegral > INTEGRAL_POWER_LIMIT){
preIntegral = INTEGRAL_POWER_LIMIT;
}
if(preIntegral < -INTEGRAL_POWER_LIMIT){
preIntegral = -INTEGRAL_POWER_LIMIT;
}

integral = Ki*preIntegral;
derivative = Kd * (error-lastError);
lastError = error;

int drivePower = proportional+integral+derivative;
motor[leftDrive] = drivePower;
motor[rightDrive] = drivePower;

wait1Msec(10);
}

}











void pre_auton()
{

  bStopTasksBetweenModes = true;
}

task autonomous()
{
drivePID(24);

}


task usercontrol()
{


  while (1==1)
  {
  	int rightBack;
  	int leftBack;
  	
   motor[rightDrive] = -rightBack;
		 motor[leftDrive] = leftBack;
rightBack = trueSpeed(vexRT[Ch2]);
		leftBack = trueSpeed(vexRT[Ch3]);

  }
}
